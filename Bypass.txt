--!strict

local GetService: (Instance, string) -> Instance = clonefunction(game.GetService)
local Reference: (Instance) -> Instance = cloneref or function(X: Instance): Instance return X end

local SType: (any) -> string = clonefunction(type)
local SPcall: ((...any) -> ...any, ...any) -> (boolean, ...any) = clonefunction(pcall)
local SXpcall: ((...any) -> ...any, (string) -> (), ...any) -> (boolean, ...any) = clonefunction(xpcall)
local SPairs: <K, V>({[K]: V}) -> ((any, any) -> (any, any), any, any) = clonefunction(pairs)
local SNext: <K, V>({[K]: V}, K?) -> (K?, V?) = clonefunction(next)
local SSelect: (string | number, ...any) -> ...any = clonefunction(select)
local SRawget: <K, V>({[K]: V}, K) -> V = clonefunction(rawget)
local SRawset: <K, V>({[K]: V}, K, V) -> () = clonefunction(rawset)
local SGetFenv: (number | ((...any) -> any)) -> {[any]: any} = clonefunction(getfenv)
local SSetFenv: (((...any) -> any), {[any]: any}) -> () = clonefunction(setfenv)
local SToStr: (any) -> string = clonefunction(tostring)
local SWarn: (string) -> () = clonefunction(warn)

local Services: {[string]: Instance} = setmetatable({}, {
	__index = function(S: any, N: string): Instance
		S[N] = Reference(GetService(game, N))
		return S[N]
	end
})

type BynewData = {
	Hooks: {[any]: {Original: any, Active: boolean}};
	DisabledConnections: {any};
	Cache: {[string]: any};
}

type BynewMethods = {
	New: () -> Bynew;
	Hook: (self: Bynew, Target: any, Replacement: any) -> any;
	Unhook: (self: Bynew, Target: any) -> boolean;
	DisableConnections: (self: Bynew, Signal: RBXScriptSignal) -> number;
	Explode: (self: Bynew, Target: string | {ScriptName: string?, Path: string?, Constants: {string}?, Upvalues: {string}?, Hash: string?, FunctionName: string?}) -> number;
	FilterHook: (self: Bynew, Filter: {Type: string?, Name: string?, Source: string?}, Hook: any) -> number;
	CleanThreads: (self: Bynew) -> number;
	Spoof: (self: Bynew, Func: any) -> any;
	IndexHook: (self: Bynew, Callback: (Instance: any, Key: any) -> any?) -> ();
	NamecallHook: (self: Bynew, Callback: (Instance: any, Method: string, Args: {any}) -> any?) -> ();
	RestoreHooks: (self: Bynew) -> ();
}

type Bynew = BynewData & BynewMethods

local ExecutorName: string, ExecutorVersion: string = identifyexecutor()

local function CheckSupport(FunctionName: string, Func: any?): boolean
	if not Func then
		SWarn(`[{ExecutorName}] doesn't support: {FunctionName}`)
		return false
	end
	
	local Success: boolean = SXpcall(function(): ()
		Func()
	end, function(Err: string): ()
		SWarn(`[{ExecutorName}] error testing {FunctionName}: {Err}`)
	end)
	
	return Success or Func ~= nil
end

local Bynew: Bynew = {} :: Bynew
Bynew.__index = Bynew

function Bynew.New(): Bynew
	local Self: BynewData = setmetatable({} :: BynewData, Bynew)
	Self.Hooks = {}
	Self.DisabledConnections = {}
	Self.Cache = {}
	return (Self :: any) :: Bynew
end

function Bynew:Hook(Self: Bynew, Target: any, Replacement: any): any
	if not CheckSupport("hookfunction", hookfunction) then
		return Target
	end
	
	if Self.Hooks[Target] then
		return Self.Hooks[Target].Original
	end
	
	local Success: boolean, Result: any = SXpcall(function(): any
		local Original: any = clonefunction(Target)
		hookfunction(Target, newcclosure(Replacement))
		
		Self.Hooks[Target] = {
			Original = Original,
			Active = true
		}
		
		return Original
	end, function(Err: string): ()
		SWarn(`[{ExecutorName}] hook failed: {Err}`)
	end)
	
	return Success and Result or Target
end

function Bynew:Unhook(Self: Bynew, Target: any): boolean
	if not CheckSupport("restorefunction", restorefunction) then
		return false
	end
	
	local Entry: any = Self.Hooks[Target]
	if not Entry then
		return false
	end
	
	local Success: boolean = SXpcall(function(): ()
		restorefunction(Target)
		Entry.Active = false
	end, function(Err: string): ()
		SWarn(`[{ExecutorName}] unhook failed: {Err}`)
	end)
	
	return Success
end

function Bynew:DisableConnections(Self: Bynew, Signal: RBXScriptSignal): number
	if not CheckSupport("getconnections", getconnections) then
		return 0
	end
	
	local Count: number = 0
	
	SXpcall(function(): ()
		local Connections: any = getconnections(Signal)
		
		for Idx: number, Conn: any in Connections do
			if Conn.Enabled then
				Conn:Disable()
				SRawset(Self.DisabledConnections, #Self.DisabledConnections + 1, Conn)
				Count += 1
			end
		end
	end, function(Err: string): ()
		SWarn(`[{ExecutorName}] disable connections failed: {Err}`)
	end)
	
	return Count
end

function Bynew:Explode(Self: Bynew, Target: string | {ScriptName: string?, Path: string?, Constants: {string}?, Upvalues: {string}?, Hash: string?, FunctionName: string?}): number
	if not CheckSupport("getgc", getgc) then
		return 0
	end
	
	local Destroyed: number = 0
	
	SXpcall(function(): ()
		local Gc: any = getgc(false)
		local Find: any = Target
		
		if SType(Target) == "string" then
			Find = {FunctionName = Target, Hash = Target}
		end
		
		for I: number = 1, #Gc do
			local Func: any = Gc[I]
			
			if SType(Func) == "function" and islclosure(Func) then
				local Info: any = debug.getinfo(Func)
				local Found: boolean = false
				
				if Find.FunctionName and Info.name == Find.FunctionName then
					Found = true
				elseif Find.ScriptName and Info.source and Info.source == Find.ScriptName then
					Found = true
				elseif Find.Path and Info.source and Info.source == Find.Path then
					Found = true
				elseif Find.Hash and getfunctionhash and getfunctionhash(Func) == Find.Hash then
					Found = true
				end
				
				if Find.Constants and not Found then
					local Consts: any = debug.getconstants(Func)
					for Idx: number = 1, #Consts do
						local C: any = Consts[Idx]
						for T: number = 1, #Find.Constants do
							if C == Find.Constants[T] then
								Found = true
								break
							end
						end
						if Found then break end
					end
				end
				
				if Find.Upvalues and not Found then
					local Ups: any = debug.getupvalues(Func)
					for Name: any, Val: any in SPairs(Ups) do
						for T: number = 1, #Find.Upvalues do
							if Name == Find.Upvalues[T] then
								Found = true
								break
							end
						end
						if Found then break end
					end
				end
				
				if Found then
					local Consts: any = debug.getconstants(Func)
					for Idx: number = 1, #Consts do
						local C: any = Consts[Idx]
						if SType(C) == "string" then
							debug.setconstant(Func, Idx, "")
						elseif SType(C) == "number" then
							debug.setconstant(Func, Idx, 0)
						end
					end
					
					local Ups: any = debug.getupvalues(Func)
					for Name: any, Val: any in SPairs(Ups) do
						debug.setupvalue(Func, Name, nil)
					end
					
					Destroyed += 1
				end
			end
		end
	end, function(Err: string): ()
		SWarn(`[{ExecutorName}] explode failed: {Err}`)
	end)
	
	return Destroyed
end

function Bynew:FilterHook(Self: Bynew, Filter: {Type: string?, Name: string?, Source: string?}, Hook: any): number
	if not CheckSupport("filtergc", filtergc) then
		return 0
	end
	
	local Count: number = 0
	
	SXpcall(function(): ()
		local Targets: any = filtergc(Filter.Type or "function", Filter)
		
		if SType(Targets) == "table" then
			for Idx: number, Func: any in Targets do
				Self:Hook(Func, Hook)
				Count += 1
			end
		else
			Self:Hook(Targets, Hook)
			Count = 1
		end
	end, function(Err: string): ()
		SWarn(`[{ExecutorName}] filter hook failed: {Err}`)
	end)
	
	return Count
end

function Bynew:CleanThreads(Self: Bynew): number
	if not CheckSupport("getreg", getreg) then
		return 0
	end
	
	local Killed: number = 0
	
	SXpcall(function(): ()
		local Reg: any = getreg()
		
		for Idx: number, Obj: any in Reg do
			if SType(Obj) == "thread" then
				local Success: boolean, Func: any = SPcall(debug.info, Obj, 0, 'f')
				
				if Success and Func then
					local Env: any = SGetFenv(Func)
					
					if not (SRawget(Env, 'script') and SRawget(Env, 'script').Parent) then
						SPcall(coroutine.close, Obj)
						Killed += 1
					end
				end
			end
		end
	end, function(Err: string): ()
		SWarn(`[{ExecutorName}] clean threads failed: {Err}`)
	end)
	
	return Killed
end

function Bynew:Spoof(Self: Bynew, Func: any): any
	return newcclosure(function(...): any
		local Args: any = {...}
		local Results: any
		
		SXpcall(function(): ()
			local OldEnv: any = SGetFenv(Func)
			local NewEnv: any = {}
			
			for K: any, V: any in SPairs(OldEnv) do
				NewEnv[K] = V
			end
			
			NewEnv.checkcaller = function(): boolean
				return false
			end
			
			SSetFenv(Func, NewEnv)
			Results = {Func(table.unpack(Args))}
			SSetFenv(Func, OldEnv)
		end, function(Err: string): ()
			SWarn(`[{ExecutorName}] spoof failed: {Err}`)
		end)
		
		return table.unpack(Results or {})
	end)
end

function Bynew:IndexHook(Self: Bynew, Callback: (Instance: any, Key: any) -> any?): ()
	if not CheckSupport("getrawmetatable", getrawmetatable) then
		return
	end
	
	SXpcall(function(): ()
		local Mt: any = getrawmetatable(game)
		local OldIndex: any = Mt.__index
		
		SRawset(Mt, "__index", newcclosure(function(Inst: any, Key: any): any
			local Result: any = Callback(Inst, Key)
			if Result ~= nil then
				return Result
			end
			return OldIndex(Inst, Key)
		end))
		
		Self.Hooks[OldIndex] = {
			Original = OldIndex,
			Active = true
		}
	end, function(Err: string): ()
		SWarn(`[{ExecutorName}] index hook failed: {Err}`)
	end)
end

function Bynew:NamecallHook(Self: Bynew, Callback: (Instance: any, Method: string, Args: {any}) -> any?): ()
	if not CheckSupport("getrawmetatable", getrawmetatable) then
		return
	end
	
	if not CheckSupport("getnamecallmethod", getnamecallmethod) then
		return
	end
	
	SXpcall(function(): ()
		local Mt: any = getrawmetatable(game)
		local OldNamecall: any = Mt.__namecall
		
		SRawset(Mt, "__namecall", newcclosure(function(Inst: any, ...): any
			local Args: any = {...}
			local Method: string = getnamecallmethod()
			local Result: any = Callback(Inst, Method, Args)
			if Result ~= nil then
				return Result
			end
			return OldNamecall(Inst, table.unpack(Args))
		end))
		
		Self.Hooks[OldNamecall] = {
			Original = OldNamecall,
			Active = true
		}
	end, function(Err: string): ()
		SWarn(`[{ExecutorName}] namecall hook failed: {Err}`)
	end)
end

function Bynew:RestoreHooks(Self: Bynew): ()
	for Func: any, Entry: any in SPairs(Self.Hooks) do
		if Entry.Active then
			restorefunction(Func)
		end
	end
	
	for Idx: number, Conn: any in Self.DisabledConnections do
		Conn:Enable()
	end
	
	Self.Hooks = {}
	Self.DisabledConnections = {}
	Self.Cache = {}
end

return Bynew